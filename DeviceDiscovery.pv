(* 设备发现阶段的 ProVerif 建模和分析 *)

(* 定义协议所需的基础类型 *)
type address.              (* 设备地址类型 *)
type skey.                 (* 私钥类型 *)
type pkey.                 (* 公钥类型 *)
type message.              (* 通用消息类型 *)
type nonce.                (* 随机数类型 *)
type nonceA.               (* 设备 A 的随机数类型 *)
type nonceB.               (* 设备 B 的随机数类型 *)
type session.              (* 会话标识符类型 *)
type uid.                  (* 唯一标识符类型 *)

(* 定义密码学操作 *)
fun pk(skey): pkey.                          (* 公钥生成函数 *)
fun sign(message, skey): message.            (* 签名生成函数 *)
fun verify(message, pkey): message.          (* 签名验证函数 *)
fun encrypt(message, pkey): message.         (* 加密函数 *)
fun decrypt(message, skey): message.         (* 解密函数 *)

(* 定义类型转换函数 *)
fun address_to_message(address): message.    (* 地址到消息的转换 *)
fun message_to_address(message): address.    (* 消息到地址的转换 *)
fun nonce_to_message(nonce): message.        (* 随机数到消息的转换 *)
fun message_to_nonce(message): nonce.        (* 消息到随机数的转换 *)
fun session_to_message(session): message.    (* 会话标识到消息的转换 *)
fun message_to_session(message): session.    (* 消息到会话标识的转换 *)
fun uid_to_message(uid): message.            (* 唯一标识符到消息的转换 *)
fun message_to_uid(message): uid.            (* 消息到唯一标识符的转换 *)

(* 定义消息合并与拆分操作 *)
fun concatenate(message, message): message.  (* 合并两条消息 *)
fun extract_first(message): message.         (* 提取消息的第一部分 *)
fun extract_second(message): message.        (* 提取消息的第二部分 *)

(* 定义通信信道 *)
free c: channel.  (* 公共通信信道，用于消息的发送和接收 *)

(* 定义隐藏的随机变量 *)
free deviceAKey: skey [private].         (* 设备 A 的私钥 *)
free deviceBKey: skey [private].         (* 设备 B 的私钥 *)
free randomAddress: address [private].   (* 随机生成的匿名地址 *)
free randomNonceA: nonce [private].      (* 设备 A 的随机数 *)
free randomNonceB: nonce [private].      (* 设备 B 的随机数 *)
free sessionID: session [private].       (* 会话标识符 *)
free uniqueID: uid [private].            (* 唯一标识符 *)

(* 定义协议中的事件 *)
event broadcast(address, pkey, nonce, session, uid).  (* 广播事件 *)
event receive(address, pkey, nonce, session, uid).    (* 接收事件 *)
event validate(address, pkey, nonce, session, uid).   (* 验证事件 *)

(* 广播设备的过程 *)
let broadcaster() =
    (* 生成设备 A 的公钥 *)
    let deviceAPubKey = pk(deviceAKey) in

    (* 广播设备 A 的公钥 *)
    out(c, deviceAPubKey);

    (* 使用设备 B 的公钥加密随机匿名地址 *)
    let encryptedAddress = encrypt(address_to_message(randomAddress), pk(deviceBKey)) in

    (* 将随机数、会话标识符和唯一标识符转换为消息类型 *)
    let nonceAAsMessage = nonce_to_message(randomNonceA) in
    let sessionAsMessage = session_to_message(sessionID) in
    let uidAsMessage = uid_to_message(uniqueID) in

    (* 构建签名消息 *)
    let signedMessage = concatenate(concatenate(encryptedAddress, nonceAAsMessage), concatenate(sessionAsMessage, uidAsMessage)) in
    let signedData = sign(signedMessage, deviceAKey) in

    (* 广播签名数据 *)
    out(c, signedData);

    (* 记录广播事件 *)
    event broadcast(randomAddress, deviceAPubKey, randomNonceA, sessionID, uniqueID);

    (* 接收来自设备 B 的签名响应 *)
    in(c, responseSignedData: message);

    (* 验证设备 B 的签名响应 *)
    let responseVerified = verify(responseSignedData, pk(deviceBKey)) in
    let receivedNonceB = message_to_nonce(responseVerified) in

    (* 验证随机数一致性 *)
    if receivedNonceB = randomNonceB then
        event validate(randomAddress, deviceAPubKey, randomNonceA, sessionID, uniqueID).

(* 接收设备的过程 *)
let receiver() =
    (* 接收设备 A 的公钥 *)
    in(c, receivedPubKey: pkey);

    (* 接收设备 A 的签名数据 *)
    in(c, receivedSignedData: message);

    (* 验证签名数据的完整性 *)
    let verifiedMessage = verify(receivedSignedData, receivedPubKey) in

    (* 提取加密的随机匿名地址，并使用设备 B 的私钥解密 *)
    let encryptedAddress = extract_first(verifiedMessage) in
    let decryptedAddress = message_to_address(decrypt(encryptedAddress, deviceBKey)) in

    (* 提取随机数、会话标识符和唯一标识符 *)
    let rest = extract_second(verifiedMessage) in
    let nonceAAsMessage = extract_first(rest) in
    let finalPart = extract_second(rest) in
    let sessionAsMessage = extract_first(finalPart) in
    let uidAsMessage = extract_second(finalPart) in

    (* 验证解密地址是否匹配 *)
    if decryptedAddress = randomAddress then (
        let verifiedNonceA = message_to_nonce(nonceAAsMessage) in
        let verifiedSession = message_to_session(sessionAsMessage) in
        let verifiedUID = message_to_uid(uidAsMessage) in

        (* 使用设备 B 的私钥生成签名响应 *)
        let nonceBAsMessage = nonce_to_message(randomNonceB) in
        let responseSignedData = sign(nonceBAsMessage, deviceBKey) in

        (* 返回签名响应给设备 A *)
        out(c, responseSignedData);

        (* 记录接收事件 *)
        event receive(decryptedAddress, receivedPubKey, verifiedNonceA, verifiedSession, verifiedUID)).

(* 安全目标验证 *)
(* 机密性目标：攻击者无法推导随机匿名地址 *)
query attacker(randomAddress).

(* 数据完整性目标：接收的地址、随机值、会话和唯一标识符必须与广播一致 *)
query x: address, k: pkey, n: nonce, s: session, u: uid;
    event(receive(x, k, n, s, u)) ==> event(broadcast(x, k, n, s, u)).

(* 防伪造目标：广播和验证必须严格匹配 *)
query x: address, k: pkey, n: nonce, s: session, u: uid;
    inj-event(broadcast(x, k, n, s, u)) ==> inj-event(validate(x, k, n, s, u)).

(* 协议的整体流程 *)
process
    (!broadcaster()) | (!receiver())
